# 无人机项目实施与代码实现流程（基于提供方案）

> 迁移声明：本项目的单一可信来源文档为《项目总方案与实施手册.md》。若与本文件存在不一致，请以《项目总方案与实施手册.md》为准；本文件保留为执行级拆分与说明。

本文将“无人机系统开发指南：从硬件到算法的完整实现”整理为可执行的项目流程与对应的代码实现流程，聚焦落地路径、边界与验收标准，便于按冲刺推进与并行协作。

## 总览

- 目标：完成从硬件组装、机载算法、视频链路、通信后端到网页端的端到端无人机系统，支持厘米级定位、低延迟视频、路径规划与基本自主飞行；飞控更换为“大疆 NAZA”（不可改固件），采用“RC 注入（SBUS/PPM）”实现自动控制。
- 关键技术：RTK+VIO 紧耦合定位、ROS 2+DDS、NAZA + RC 注入（SBUS/PPM）、H.265 低延迟图传、FastAPI 后端、Three.js 前端、YOLOv8 感知、A*/RRT* 规划。
- 交付物：整机+RC 桥接硬件/固件、机载程序、服务器后端、网页端、CI/CD 流水线、测试报告。

---

## 一、项目流程（阶段化 + 冲刺化）

以下与文档阶段 S1–S5 对齐，并细化到每周粒度与验收标准。

### S1 硬件采购与组装（2 周）
- 周1：
  - 采购与到货验收：DJI NAZA（如 NAZA-M V2）飞控、机架、电机/电调/电池、RTK-GPS、双目相机/IMU、图传模块、RC 桥接 MCU（STM32/ESP32/Arduino）与 SBUS/PPM 硬件。
  - 机架机械装配与电气布线：区分电机 CW/CCW，分电板焊接，电调固定与压测。
  - 验收标准：装配合规、线束固定，供电无短路，空载通电稳定。
- 周2：
  - 传感器初校准（NAZA Assistant）：加速度计/陀螺仪/磁力计/水平校准；飞行模式开关（GPS Atti/Atti/Failsafe）配置。
  - RTK 测试：基准点偏差 < 3cm；图传链路点对点接通并测得延迟基线。
  - 验收标准：NAZA Assistant 状态正常，GPS 定位稳定，RTK Fix 状态可达，视频可视。

### S2 RC 桥接与控制律开发（3 周）
- 周3：
  - RC 桥接硬件设计与接线：MCU 通过 UART 与机载电脑通讯，向 NAZA 输出 SBUS/PPM；设计三路模式控制（手动/半自/全自）。
  - 串口协议定义（自研）：PC→MCU 的 RC 通道值、心跳、故障回退策略。
  - 验收标准：示波器/逻辑分析仪验证 SBUS/PPM 波形正确；NAZA 可识别并响应通道变化。
- 周4：
  - 机载控制律（闭环）：基于自有定位（RTK/VIO）计算期望速度/姿态，映射到 RC 通道（滚转、俯仰、油门、偏航），维持 GPS Atti 下的路径跟踪。
  - 看门狗：通信中断自动回中位并切换至人工模式/返航；限幅与加速度约束。
  - 验收标准：地面悬挂/吊挂或拆桨测试下，可按 RC 注入实现小范围精准控制。
- 周5：
  - 安全策略：失联→NAZA Failsafe 触发、地理围栏（软件侧）、最大倾角/速度限制；模式切换流程与人工接管验证。
  - 验收标准：模式切换无突变；失联可可靠返航；安全联锁可用。

### S3 服务器开发（4 周）
- 周6：
  - 后端 FastAPI 框架与核心接口 /api/planning 搭建；规划库与数据模型落地。
  - MQTT Broker（EMQX）与主题结构定义；WebSocket 网关初版。
  - 验收标准：Postman/单测可调用规划接口，MQTT/WS 收发通。
- 周7：
  - 前端 Three.js 地图与3D路径编辑器原型；与 WS 打通；
  - 视频流服务器（解码/转发）结构设计与最小可用流（H.265->WS 播放）。
  - 验收标准：前端可绘制/发送路径，后端回传规划结果并渲染。
- 周8：
  - 权限/租户/设备注册基础能力；日志与指标（Prometheus/OpenTelemetry）接入。
  - 验收标准：最小权限闭环；基础监控可见。
- 周9：
  - 性能与健壮性：规划算法与消息队列的压测；视频延迟测评与调优策略预置。
  - 验收标准：端到端延迟指标与吞吐指标达标（详见“测试指标”）。

### S4 系统联调（2 周）
- 周10：
  - 单机：定点悬停（误差 < 0.5m）、矩形航线跟踪（误差 < 1m）。
  - 端到端：前端路径 -> 后端规划 -> 机载控制律 -> RC 注入 -> NAZA 控制闭环。
  - 验收标准：重复 3 次通过；异常回退与遥控接管验证。
- 周11：
  - 动态避障（感知+局部重规划）；视频/控制并发链路稳定性。
  - 验收标准：动态障碍可绕行；控制丢包<0.1%，视频卡顿<1/5min。

### S5 多机测试（3 周）
- 周12：
  - 时间同步（PTP<1ms）、多机状态广播；地理围栏/避免冲突策略。
- 周13：
  - 任务分配（改进匈牙利）；多机协同航迹。
- 周14：
  - 演示彩排与报告固化。
  - 验收标准：多机通信延迟<50ms；全程无严重故障。

### 关键路径与依赖
- 硬件就绪 → RC 桥接可用 → 机载控制律闭环 → 后端/前端闭环 → 感知/规划 → 多机协同。
- 风险点：RTK 环境、时间同步、图传干扰、电磁兼容、算法实时性；NAZA 为黑盒不可注入外部里程计。回退：仅 RTK 或仅 VIO 辅助+人工接管/返航。

---

## 二、代码实现流程总览（边界与数据流）

模块与语言/框架：
- RC 桥接 MCU 固件：C/C++（SBUS/PPM 生成、串口协议）
- 机载（ROS 2 Foxy）：C++/Python（状态估计、规划桥、控制桥、感知）
- 感知：Python（YOLOv8/Torch、OpenCV/GStreamer）
- 规划：Python（A*/RRT*，与 ROS 2/后端交互）
- 后端：Python（FastAPI、MQTT、WebSocket、FFmpeg/媒体转发）
- 前端：JS/TS（Three.js/Mapbox、WS 客户端、播放器）
- 运维：Docker Compose/K8s（可演进）、CI（GitHub Actions）

数据流：
- 传感器(相机/IMU/GNSS) → 机载估计节点（融合）→ ROS2 话题 → 规划 → 控制律（期望姿/速）→ RC 桥（串口→SBUS/PPM）→ NAZA
- 摄像头 → H.265 编码 → 无线 → 服务器解码/转发 → WebSocket → 浏览器播放器
- 遥测/指令：机载/后端 → MQTT/WS → 前端/控制台

边界：
- NAZA 与机载：仅通过 RC 输入（SBUS/PPM）控制，不支持外部里程计/姿态注入
- 机载与后端：MQTT/WS/REST
- 后端与前端：WS/HTTP；视频独立通道

---

## 三、仓库结构建议（Monorepo）

```
repo/
├─ rc-bridge-mcu/              # MCU 固件：SBUS/PPM 生成、串口协议
├─ onboard/                    # 机载 ROS 2 节点
│  ├─ perception/              # YOLOv8 检测/跟踪
│  ├─ estimation/              # VIO/RTK 融合（内部自用）
│  ├─ planning/                # A*/RRT* 与局部重规划
│  └─ control_bridge/          # ROS2 -> RC 命令（串口）
├─ backend/                    # FastAPI + 媒体服务 + MQTT/WS
├─ frontend/                   # Three.js/Mapbox 网页端
├─ comms/                      # 协议适配（MQTT 客户端、WS 客户端）
├─ video/                      # 编解码与转发脚本/服务
├─ hw/                         # 接线图、RC 桥接原理图/PCB（可选）
├─ ops/                        # Docker/CI/CD/监控
└─ docs/                       # 设计与测试文档、NAZA 调参与安全规范
```

最小脚手架建议：每个子目录包含 README.md（运行/配置）、requirements/依赖清单或 CMake/colcon 配置，提供本地快速起步说明。

---

## 四、模块实现步骤与骨架

### 4.1 RC 桥接（MCU 固件 + 串口协议）
实现目标：机载电脑输出期望 RC 通道值，经串口发送至 MCU；MCU 生成 SBUS/PPM 信号输入 NAZA，从而在 GPS Atti 模式下实现自动控制与模式切换。

步骤：
1) 选择输出协议（SBUS 优先，快速稳定；备选 PPM）；
2) 设计串口协议：心跳、帧序号、通道数组、CRC；失联超时回中并切换手动；
3) MCU 定时器与 DMA 生成 SBUS/PPM；
4) 三段式模式控制（手动/半自/全自）与失联→NAZA Failsafe 打通；
5) 台架验证：示波器/逻辑分析仪、NAZA Assistant 校验通道。

PC→MCU 串口消息（示例 JSON，亦可换为二进制以降延迟）
```json
{
  "seq": 1024,
  "ts": 1699999999,
  "ch": [1500,1500,1520,1500,1800,1500,1500,1500,1500,1500,1500,1500],
  "mode": "auto",
  "crc": 12345
}
```

MCU 侧伪代码（C）：
```c
void loop() {
  if (serial_read(msg) && check_crc(msg)) {
    update_channels(msg.ch);
    last_rx = now();
  }
  if (now() - last_rx > TIMEOUT_MS) {
    set_channels_neutral();
    set_mode_manual(); // 触发人工/返航
  }
  sbus_emit_frame(channels); // 100Hz
}
```

验收：台架 NAZA Assistant 中各通道响应线性稳定；失联回中与模式切换可靠。

### 4.2 机载 ROS 2 栈（estimation/planning/control）
- estimation：桥接 VIO/RTK 输出到 ROS2；发布 nav_msgs/Odometry
- planning：订阅地图/障碍，发布路径 nav_msgs/Path；局部重规划 RRT*/DWA
- control_bridge：订阅轨迹，生成期望速度/姿态，映射至 RC 通道并通过串口下发给 MCU

ROS 2 节点骨架（Python/rclpy）：
```python
import rclpy
from rclpy.node import Node

class Planner(Node):
    def __init__(self):
        super().__init__('planner')
        # self.create_subscription(...)
        # self.publisher_ = self.create_publisher(...)
    def tick(self):
    # 读取定位、障碍 -> 规划 -> 生成期望速度/姿态 -> 映射 RC -> 串口下发
        pass

def main():
    rclpy.init()
    node = Planner()
    rclpy.spin(node)
    node.destroy_node(); rclpy.shutdown()
```

### 4.3 后端 FastAPI（规划与消息网关）
端点：
- POST /api/planning：输入 start/end/obstacles，输出 path
- WS /ws：前端推送路径点/控制命令，后端向前端推送遥测/视频信令
- MQTT：桥接 drones/+/telemetry 与 drones/+/command

骨架（Python/FastAPI）：
```python
from fastapi import FastAPI, WebSocket
from pydantic import BaseModel

app = FastAPI()

class PathRequest(BaseModel):
    start: list[float]
    end: list[float]
    obstacles: list[list[float]]

@app.post('/api/planning')
def plan(req: PathRequest):
    path = a_star(req.start, req.end, req.obstacles)
    return {"path": path}

@app.websocket('/ws')
async def ws_endpoint(ws: WebSocket):
    await ws.accept()
    # 收/发事件：path.update、telemetry
```

### 4.4 前端 Three.js 路径编辑器
要点：
- 地图初始化（Mapbox+Threebox）
- 交互绘制路径点，渲染 polyline
- 通过 WS 发送 path.update；订阅后端规划结果并渲染

片段（关键步骤）：
```javascript
const ws = new WebSocket('wss://server/ws');
function sendPath(points) { ws.send(JSON.stringify({type:'path.update', points})); }
```

### 4.5 感知（YOLOv8）
要点：
- 选择轻量模型（yolov8n/s），GPU 加速；
- 从 UDP/RTSP 取流；检测后输出障碍物集合（位置、尺度、类别、置信度）。

骨架（Python）：
```python
from ultralytics import YOLO
def detect(frame, classes=[0,1,16]):
    model = YOLO('yolov8n.pt')
    results = model(frame, classes=classes)
    return results
```

### 4.6 规划（A* + 局部 RRT*/DWA）
要点：
- 全局：栅格/航点图上的 A*；
- 局部：RRT* 重规划周期 < 100ms；
- 控制接口：输出期望轨迹/速度曲线。

骨架（Python）：
```python
def a_star(start, goal, obstacles):
    # open/closed 集合、g/f 代价、启发式，返回路径数组
    return []
```

### 4.7 控制/RC 注入桥
- 输入：规划器输出的期望速度/姿态；
- 处理：PID/增益调度，将期望映射为 RC 通道（CH1 roll、CH2 pitch、CH3 throttle、CH4 yaw、CH5 模式…），限幅/加速度保护；
- 输出：串口消息至 MCU，MCU 生成 SBUS/PPM 注入 NAZA。

Python 侧示意（RC 映射与串口发送）：
```python
import serial, struct, time

def mix_to_rc(vx, vy, vz, yaw_rate):
  # 简化：vx→pitch, vy→roll, vz→throttle, yaw_rate→yaw
  def mm(val, vmax):
    v = max(min(val / vmax, 1.0), -1.0)
    return int(1500 + v * 400)  # 1100~1900us
  ch1 = mm(vy, 3.0)
  ch2 = mm(vx, 3.0)
  ch3 = mm(vz, 2.0)
  ch4 = mm(yaw_rate, 1.0)
  ch5 = 1800  # auto
  return [ch1, ch2, ch3, ch4, ch5]

ser = serial.Serial('COM5', 115200)
while True:
  ch = mix_to_rc(0.5, 0.0, 0.0, 0.0)
  payload = struct.pack('<H12H', 0xA55A, *([*ch] + [1500]*(12-len(ch))))
  ser.write(payload)
  time.sleep(0.01)
```

### 4.8 视频链路
- 编码：H.265（硬编优先，关键帧间隔、无 B 帧、低缓冲）；
- 传输：UDP + FEC；
- 服务器：解码后通过 WS/LL-HLS 转发；
- 播放：MSE/Canvas 播放器，抖动缓冲 10–50ms。

---

## 五、接口与消息契约（契约优先）

### 5.1 HTTP（FastAPI）
- POST /api/planning
  - Request: { start:[x,y,z], end:[x,y,z], obstacles:[[x,y,z,r], ...] }
  - Response: { path: [[x,y,z], ...], cost: number? }

### 5.2 WebSocket 事件
- 上行：{ type: 'path.update', points: [[lng,lat,alt], ...] }
- 下行：{ type: 'telemetry', pose: {x,y,z,yaw}, battery: %, link: {rssi,rate} }

### 5.3 MQTT 主题（EMQX）
- drones/{id}/telemetry → { pose, vel, status }
- drones/{id}/command → { mode:'manual'|'auto'|'failsafe', target: {...} }
QoS：0（视频外链）、1（遥测）、2（关键指令可选，建议 1）。

### 5.4 ROS 2 话题
- /odom nav_msgs/Odometry（融合位姿）
- /path nav_msgs/Path（规划结果）
- /obstacles custom_msgs/Obstacles（感知输出；必要时定义 msg）
- /rc_cmd custom_msgs/RcCmd（RC 通道期望，供串口桥使用）

### 5.5 RC 通道映射（NAZA 常规）
- CH1：Roll、CH2：Pitch、CH3：Throttle、CH4：Yaw
- CH5：Mode（GPS Atti / Atti / Failsafe）
- CH6+：增益/自定义（如速度限制）
注意：确保注入不屏蔽遥控器物理急停/返航开关；失联时让 NAZA 进入 Failsafe。

---

## 六、环境与工具链要点

- Windows 开发机：前端/后端/算法开发；建议 WSL/容器化以贴近部署环境。
- Jetson/机载：CUDA/TensorRT（可选），ROS 2 Foxy，pyserial/rclpy/rclcpp。
- MCU 构建：STM32CubeIDE/PlatformIO/Arduino；串口调试工具；
- 媒体：FFmpeg/GStreamer 工具链；弱网场景预设参数集。
- 监控：Prometheus + Grafana；日志统一结构化输出（JSON）。

---

## 七、测试与 CI/CD

- 单元测试：
  - 规划算法：A* 路径正确性、无路场景；
  - 后端：请求/响应契约、边界校验；
- 集成测试：
  - 台架/HIL：拆桨或动力隔离，路径下发→姿态/位置响应；
  - 视频链路：延迟/丢包回放测试，目标 ≤ 150ms 端到端；
- 性能指标：
  - 定位：室外 RTK 误差 ≤ 3cm；室内 VIO 跟踪稳定；
  - 控制：跟踪误差 < 1m（矩形航线）；
  - 通信：多机延迟 < 50ms；丢包 < 0.1%；
- CI/CD：
  - Lint/TypeCheck/UnitTest；容器镜像构建（backend/perception/planning）；
  - MCU 固件编译检查与串口协议回归测试（Host 模拟器）；
  - 部署：Docker Compose（可演进至 K8s）。

---

## 八、里程碑与风险

里程碑 = S1–S5 的阶段验收；每阶段形成报告（测试数据、问题单与改进项）。

主要风险与缓解：
- RTK 不稳定 → 切换 VIO/VIO+轮速（若有）并限制速度；
- 时间同步偏差 → 硬件 PPS + 软件校准，增加时延观测；
- 图传抖动/丢包 → FEC、码率自适应、Jitter Buffer；
- 算法实时性不足 → 模型剪枝/张量加速、降分辨率、预计算地图库；
- 安规/合规 → 地理围栏、遥控优先权、禁飞区内自动锁定；数据隐私合规。

---

## 九、落地清单（可执行）

- 立刻可做：
  1) 创建 monorepo 目录与 README；
  2) 设计并实现 RC 串口协议与 Host 端发送器；
  3) MCU 端 SBUS/PPM 生成最小固件；
  4) 机载 ROS2 节点模板与 /rc_cmd 话题契约；
  5) 前端路径编辑器最小功能 + WS；后端 /api/planning 骨架。
- 下一步：
  1) YOLOv8 + 障碍消息；
  2) 局部 RRT* 重规划；
  3) 视频链路端到端低延迟调优；
  4) 多机 PTP 同步与协同策略；
  5) 实机小场地闭环测试与 NAZA 模式切换安全校验。

备注：以上流程与骨架紧贴提供文档，适合迭代式推进；如需，我可进一步在仓库内生成对应子模块的最小可运行代码与 README。
